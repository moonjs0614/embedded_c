# 비트연산

## 기본 비트연산
> 연산자 쓸 때 &&, ||를 쓰지 않도록 조심

& 연산, | 연산, << 연산, >> 연산, ~ 연산, 0b, 0x, 0o ... LSB, MSB, b = (a >> 2) & 0x01;, b = (a >> 5) & 0x11;

## 비트 Set / Clear

**비트 clear**
- 특정 비트를 0으로 만드는 것을 clear 한다고 표현한다.

**비트 set**
- 특정 비트를 1로 만드는 것을 set 한다라고 한다.

## 비트 Set / Clear 예제

> 1번 bit set 한 값 저장하기
> - `a1set = (0x1 << 1) | a;`

> 1\~3번 bit set 하기
> - `a13set = (0x7 << 1) | a;`

> 2번 bit clear 하기
> - `a2clr = a & ~(1 << 2);`

> 1~\3번 bit clear 하기
> - `a13clr = a & ~(0x7 << 1);`

## XOR

- OR와 비슷함 (왜?)
- 10진수의 덧셈과 비슷한 동작을 한다.

> `1101 ^ 1001 = 0100`
> 
> `0xFA ^ 0xED = 0x17`

# 음수처리방법

## 2의 보수

**숫자를 뒤집고, 1을 더한 수**
- bit에 따라 값이 달라진다. (8bit 등)
- 7bit 111000 의 2의 보수 : 000111 + 1 -> 001000

**2의 보수 특징**
- 1의 보수 처럼 한번 더 2의 보수를 취하면 원래 값으로 돌아온다.
  - 101 => 011 => 101
  - 111 => 001 => 111
  - 000 => 000 => 000

**부호비트 사용**
char 변수는 8bit를 사용, MSB(최상위 비트)를 부호 비트로 사용
- 음수일때는 MSB가 1이고, 나머지 7비트를 2의 보수를 취한 값을 저장

# Overflow / Underflow

0x1110 0100 1100 0100 음수이다.
0x e4c4

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
	setbuf(stdout, NULL);
	int a = 100; // 0x64
	int b = 200; // 0xc8
	char buf[10];
	sprintf(buf, "%X%X", a, b);
	
	return 0;
}
```